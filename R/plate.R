#' @import dplyr
#' @import tidyr
#' @importFrom purrr map_lgl map_int map_df map
#' @import tibble
#' @import readxl
#' @import digest

# Helper function to find the the plates (6, 12, 24, 48 or 96 well plates)
# Plates are defined as having column and row headers
# Columns are named from 1 up to 12
# Rows are named from A up to H
find_plate <- function(.df) {
  valid_plate <- tribble(~format, ~n_row, ~n_col,
                         6, 2, 3,
                         12, 3, 4,
                         24, 4, 6,
                         48, 6, 8,
                         96, 8, 12)
  
  max_col <- max(valid_plate[["n_col"]])
  max_row <- max(valid_plate[["n_row"]])
  
  c(row = LETTERS[1:max_row], col = 1:max_col)
  
  .t <- which(.df == "A", arr.ind = TRUE) %>%
    as_tibble() %>%
    mutate(row = row - 1,
           header_row = map2(col, row, ~.df[(.y + 1):(.y + max_row), .x]),
           header_col = map2(col, row, ~.df[.y, (.x + 1):(min(.x + max_col, ncol(.df)))])) %>%
    mutate_at(vars(header_row:header_col), map, flatten_chr) %>%
    gather(header_type, header, starts_with("header")) %>%
    mutate(header_type = gsub("header_", "", header_type),
           t = recode(header_type, "row" = list(LETTERS[1:max_row]), "col" = list(1:max_col)),
           t = map2(header, t, quietly(`==`)),
           t = map(t, "result"),
           t = map(t, rle),
           t = map(t, transpose),
           t = map(t, bind_rows),
           t = map(t, `[`, 1, TRUE))
  
  if (nrow(.t) == 0) return(tibble(row = numeric(0), col = numeric(0)))
  
  .t %>%
    unnest(t) %>%
    filter(values) %>%
    select(-header, -values) %>%
    rename(header_n = header_type) %>%
    spread(header_n, lengths, sep = "_") %>%
    mutate(plate = map2(header_n_row, header_n_col, ~ valid_plate %>% filter(n_row <= .x, n_col <= .y) %>% top_n(n = 1, format))) %>%
    unnest(plate) %>%
    select(-starts_with("header")) %>%
    mutate(range = pmap(list(col, row, n_col, n_row), function(x, y, n_x, n_y) cell_limits(c(y, x), c(y + n_y, x + n_x))))
}

# Helper function to find the localisation of ID tables (extended information for the layout plates)
# These tables must contain a header containing at least the column "id" which refering to the layout plate cells.
find_id <- function(.df) {
  empty_row <- .df %>%
    is.na() %>%
    t() %>%
    as_tibble() %>%
    map(all) %>%
    flatten_lgl() %>% 
    set_names(seq_along(.))
  
  .t <- which(.df == "id", arr.ind = TRUE) %>%
    as_tibble() %>%
    filter(c(TRUE, empty_row)[row]) %>% # previous row should be empty
    mutate(t = map(row, ~empty_row[.:length(empty_row)]),
           t = map(t, rle),
           t = map(t, transpose),
           t = map(t, bind_rows),
           t = map(t, `[`, 1, TRUE))
  
  if (nrow(.t) == 0) return(tibble(row = numeric(0), col = numeric(0)))
  
  .t %>% 
    unnest(t) %>%
    filter(!values) %>%
    select(row, n_row = lengths) %>% # the number of non empty lines is the length of our table
    mutate(range = map2(row, n_row, ~cell_rows(c(.x, .x + .y))))
}

join_if_id <- function(.x, .y, .by) {
  if (is.null(.x) || length(.x) == 0) return(.y)
  .x %>%
    mutate_at(vars(id), as.character) %>%
    right_join(.y, by = .by)
}

#' List plate elements in excel files
#'
#' List all plate (data and layout) and associated extended id tables.
#' 
#' @param path vector containing the path to the excel files.
#' 
#' @return A tibble listing the found elements: element (plate or id), position (row, col), format (6, 12, 24, 48, 96 well plate), range (cellranger::cell_limits S3 object to be used in read_excel)
#'
#' @export
list_elements <- function(path) {
  associated_id <- quo(element == "id" & lag(element) == "plate")
  path %>%
    set_names() %>%
    map(excel_sheets) %>%
    enframe("path", "sheet_name") %>%
    unnest() %>%
    group_by(path) %>%
    mutate(sheet_pos = seq_along(sheet_name),
           data = map2(path, sheet_name, read_excel, col_names = FALSE, col_types = "text", range = cell_limits(ul = c(1, 1))),
           plate = map(data, find_plate),
           id = map(data, find_id)) %>%
    ungroup() %>%
    select(-data) %>%
    gather(element, where, plate, id) %>%
    unnest() %>%
    arrange(path, sheet_pos, row) %>%
    mutate(element_id = replace(NA, element == "plate", seq_along(element[element == "plate"])),
           element_id = walk(replace(element_id, !!associated_id, lag(element_id)[!!associated_id]),
                             ~if (is.na(.)) warning("Found orphan ID table", call. = FALSE))) %>%
    select(element_id, everything(), -n_row, -n_col)
}

#' Read plate elements in excel files
#'
#' Read all plate (data and layout) and associated extended id tables.
#' 
#' @param .df tibble generated by list_elements().
#' 
#' @return A nested tibble containing the data elements: is_layout (boolean), format (6, 12, 24, 48, 96 well plate), data (nested tibble containing the tidy data)
#'
#' @export
read_elements <- function(.df) {
  .df %>%
    filter(!is.na(element_id)) %>%
    mutate(element = forcats::as_factor(element),
           element = forcats::fct_expand(element, c("plate", "id")),
           data = pmap(list(path, sheet_name, range), read_excel)) %>%
    select(element_id:element, data) %>%
    spread(element, data) %>%
    mutate(is_layout = !map_lgl(id, is_empty),
           is_data = at_depth(plate, 2, is_numeric),
           is_data = map(is_data, flatten_lgl),
           is_data = map(is_data, `[`, -1),
           is_data = map_lgl(is_data, all),
           is_layout = map2_lgl(!is_data, is_layout, any),
           plate = map(plate, gather, col, value, -1),
           plate = map(plate, set_names, c("row", "col", "value")),
           plate = map2(id, plate, join_if_id, c("id" = "value")),
           format = map_int(plate, nrow),
           path = basename(path)) %>%
    rename(file = path, data = plate) %>%
    select(-data, everything(), -is_data, -id, data)
}

#' @export
join_layout <- function(.df) {
  n_id <- .df %>%
    group_by(file, format) %>%
    filter(is_layout) %>%
    summarise(n = n()) %>%
    select(file, n) %>%
    deframe()
  
  if (any(n_id > 1)) stop("Cannot join multiple layouts...")
  
  .df %>%
    group_by(file, format) %>%
    mutate(data_id = replace(list(NULL), length(data[is_layout]) > 0, data[is_layout])) %>%
    filter(!is_layout, !map_lgl(data_id, is_empty)) %>%
    #mutate_at(c("data", "data_id"), map, function(x) mutate_if(x, names(x) == "id", as.character)) %>% 
    mutate(data = map2(data, data_id, left_join, by = c("row", "col"))) %>%
    select(-data_id, -is_layout) %>%
    ungroup()
}

#' @export
read_plate <- function(path) {
  path %>%
    list_elements() %>%
    read_elements() %>%
    join_layout() %>%
    unnest()
}

